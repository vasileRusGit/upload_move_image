                                         Testing Methodologies
Functional testing :
1-Unit Testing
2- Integration Testing
3 - System Testing
4 - Acceptance Testing
Non-Functional Testing:
5 - Performance Testing
6 - Security Testing
7 - Usability Testing
7 Compatibility Testing

Black box testing – Internal system design is not considered in this type of testing. Tests are based on requirements and functionality.
White box testing – This testing is based on knowledge of the internal logic of an application’s code. Also known as Glass box Testing. Internal software and code working should be known for this type of testing. Tests are based on coverage of code statements, branches, paths, conditions.
Smoke Testing
A smoke tester will select and run a subset of test cases that cover the most important functionality of a component or system, to ascertain if crucial functions of the software work correctly
Sanity Testing
Sanity testing is performed to ascertain that the bugs have been fixed and no further issues are introduced due to these changes
Alfa Testing
Alpha testing is a type of acceptance testing; performed to identify all possible issues/bugs before releasing the product to everyday users or public.  The focus of this testing is to simulate real users by using blackbox and whitebox techniques. To put it as simple as possible, this kind of testing is called alpha only because it is done early on, near the end of the development of the software, and before Beta testing
Beta Testing of a product is performed by "real users" of the software application in a "real environment" and can be considered as a form of external user acceptance testing.It is the final test before shipping a product to the customers. Direct feedback from customers is a major advantage of Beta Testing. This testing helps to tests the product in real time environment.
Agile Testing
 Agile testing is software testing, which involves the testing of the software from the customer point of view.  The importance of this testing is that, unlike normal testing process, this testing does not wait for development team to complete the coding first and then doing testing. The coding and testing both goes simultaneously.  It requires continuous customer interaction.

Unit Testing
The Unit testing part of a testing methodology is the testing of individual software modules or components that make up an application or system. These tests are usually written by the developers of the module and in a test-driven-development methodology (such as Agile, Scrum or XP) they are actually written before the module is created as part of the specification. Each module function is tested by a specific unit test fixture written in the same programming language as the module.
Integration Testing
The Integration testing part of a testing methodology is the testing of the different modules/components that have been successfully unit tested when integrated together to perform specific tasks and activities (also known as scenario testing). This type of testing is especially relevant to client/server and distributed systems.
System Testing
The system testing part of a testing methodology involves testing the entire system for errors and bugs. This test is carried out by interfacing the hardware and software components of the entire system (that have been previously unit tested and integration tested), and then testing it as a whole. This testing is listed under the black-box testing method, where the software is checked for user-expected working conditions as well as potential exception and edge conditions.
Acceptance Testing
The acceptance testing part of a testing methodology is the final phase of functional software testing and involves making sure that all the product/project requirements have been met and that the end-users and customers have tested the system to make sure it operates as expected and meets all their defined requirements:
Verificatition and Validation
In verification, all the key aspects of software developments are taken in concern like code, specifications, requirements and document plans.  Verification is done on the basis of four things list of issues, checklist, walkthroughs and inspection meetings. Following verification, validation is done, it involves actual testing, and all the verification aspects are checked thoroughly in validation.

Non-Functional Testing
On the other hand, non-functional testing involves testing the application against the non-functional requirements, which typically involve measuring/testing the application against defined technical qualities (also known as the ‘-ilities’ because they all end in ‘-ility), for example: vulnerability, scalability, usability. Some examples of non-functional testing are described below:
Performance, Load, Stress Testing
There are several different types of performance testing in most testing methodologies, for example: performance testing is measuring how a system behaves under an increasing load (both numbers of users and data volumes), load testing is verifying that the system can operate at the required response times when subjected to its expected load, and stress testing is finding the failure point(s) in the system when the tested load exceeds that which it can support.
Security, Vulnerability Testing
Security testing tests the software for confidentiality, integrity, authentication, availability, and non-repudiation. Individual tests are conducted to prevent any unauthorized access to the software code.
Usability Testing
The usability testing part of a testing methodology looks at the end-user usability aspect of the software. The ease with which a user can access the product forms the main testing point. Usability testing looks at five aspects of testing, - learnability, efficiency, satisfaction, memorability, and errors.
Compatibility Testing
The compatibility part of a testing methodology tests that the product or application is compatible with all the specified operating systems, hardware platforms, web browsers, mobile devices, and other designed third-party programs (e.g. browser plugins). Compatibility tests check that the product works as expected across all the different hardware/software combinations and that all functionality is consistently supported.
